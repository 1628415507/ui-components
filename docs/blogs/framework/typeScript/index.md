---
theme: simplicity-green
highlight: a11y-dark
---

> - TypeScript 可以在 JavaScript 的基础上，对变量的数据类型加以限制。
> - [tyscript 中文文档](https://www.tslang.cn/docs/handbook/basic-types.html)
> - [在线编辑地址](https://www.typescriptlang.org/zh/play?ssl=141&ssc=3&pln=134&pc=1#code/PTAEgQGQv9UGnNAdTQ7Y0N4+ho9UIgMAoANgUwC6gFtsAuUAbQGdcAnASwDsBzAGlHoFcCAjbagXVABecgCJAzpojWAJgAsfdCELYyABgHCAjKBApApUaBMVPREyG9aC07kB9ArDhAWeaA+ORQZsHAqCcpQAb1AByJw1-VkDHKRCApwBmf1AAX3QAYwB7egoUnAA6TBTGAAovZDIwiPVBTQBKG0VwAB9QFEAVAMAIFQwcfFT2agpsDVIqOiZQBvceaiEAwErnQBt4gDd2bFBY5JTu3q1NW1Aunr7JmkXtMANQdFwATwAHJd3egGVU6iXhf0BfTTiG-0A6+kAOPQ+RgFAHBqQI+WDwoAoTz6pDu2EeKWek3e-m2HUh0KkoGIcIRSNegAB6QA0QQDFNZtuBAJ-agEMYwAhbihAAppgDYlDCKQBYCYBx+IYuF4ADMAIZJbCAUuNALj0gHvlQCncoAs7UAknI0+nIZnobl8wVLBWMpm+dCgPWgQCwKoAHzwGNAYLF1+sAHnqABfjYIB1bVIY14ZD4zBAgH95QAm9M7qK7QIBb6MAqzZylCALjkHYARv0ACEa02CRy16wCMTm8APymoaMQFcFKZbD8+jusCc0CpwB90YA7f1AYfFgEgEwB6OoByA0ToGe-IAJmlMBdQIBftUAsj4Z83HVv5zv0buVsOAK+VAN-RTcAMP+AIM1ADnmlMAboqAbfjAPH0gDv5QCcpoBGHUAWPIGQBADOhEuibj00qRNUrtcIfC3jaR-IAJlQ-IRbtodpFUVhTGYFsU1IAVMF6ED9T7QcAkAWjle1RRJFBvDJ6CyAdBH8QA4-yQkADAXOdAFg5cUDxqOxAF-FWAUFpZlWTADQslAXl2HoJJcFoNJaUATtNAHh9OVqPQVj2M4tJQA7dt8gADydThxlYC45O4XhKmU8YdRg55cG6ehQGk0AAGpQAuABuS90Ek-INGkSpzMUKRmMADeVAHnE3iBNlajAAh-8VZ0bQA73QXYjAArjQAFYMASH-wXwST+lAGT1N4RSEuoSohAAPjYeTeEmESOK4vT4sylTqCSorxjUsrspfLS8F0-SjJMiyYvyKRWGiapFGiLJvUuG5AGdFQA6VPtQBu5UE2BFS8sLIt6pZJIAFWuF44v5ZLWC4ZLUsEDLfSiiT23bKRSHmxacrYvLxMK31St9CrfU0-VtLqgzjIuCzFBkbqvVVagBSFQaRrGiappVegeR+9U9vbABJUG1SFe69XyFbKpK0B1pR26suoCz0Uk6Ijv2mGwd+pbcrEgrZJR66scx4qEdHHTqD057GpQqjYEAWcTAF94jAyfy0c5l4XpLpp5LhLO8mBaF7BCsGc0KrlphxdE-nnkFvYRbphpFcYWmNO1s1hgaOYUlodt6cUGaUl5QASJUAWtNACHlcaUBbWheTiq33YMipXl9fxUuqmCHtqpnQAAOSxmSslwFJ7kNgpKiyCgrkwWhcHyfx-ayNXpfyROACtTfoDP-bsltEhg7BIKWN2PcW636p9gIdf9+masZ5mk5TtOS8TnONYLove-MmDEjZ0BAH7tQBuOUAeudAGCNQBS+kVXaAHdSAAdQYTsV8mFet5SFfdqrkhQAACTmgBZAAZABRHAiFByZOySTg3FwLIkjbHk7+wB-0-8dstA5j+12vyTAmAAAiQDSBhxSO2bAV9aBUCfikF+f8sgAEdFjUAuPcY+HFEQAEFwEZ0AcA6ox8siSRvoLUGiCqBuF4BnJIqckgAGtIh8wuifC+axeg0LfgHFsqR0jRWoIwCgpAoaEPEa-UGFBJj8lkX-CgLYV5UJwNQdOGhqgwRERkbIuQChKIkdUeIrAIK9A6nYQA2zZoG2CgVytInaAHozOaC5OSAAJ5QAporEUADAqzjYALkAOXGTJ-GKicoANGVlbnT0mbN+acLgAB45ppSRuI0gc0KpzV8AzOqJiEjbEAJvxgAqOTmoeFxOsFyAAEjSUgAV+MAHtqgAeBUAKP6gBvDMAOn6lT45nHiaDRJSSdZpP8LMBYSxoiAAtFQAbdqADcLEBihSnlJcb6Gp9TmntK6TtPpnFLhJN9GknR2w2HYAuNbEGxMIYADVFgAGE1h7AAKz03oPyIgQ4mCsCuHQIUYtx7emOac3kwZADtwR0wAT7qAFP3FA1zsB3PWNgB5tImyAHQlQAFhELkAB9ugBlfUAHFyoBAAYBC8oggBMAjqPir5tAhTEsAFj-5wTpwr2AABWoCkK4CjhAAobjChlvQnmKGnIAX4DlmvOwIAGJUKVClrASEpZx0RsNIDy7AzLWXsoCES7AqJFBytioq5VbLkRXDiIofc0YJXYAqZSWkFFQChmQNRG+0keT0HbBQBaNwFzCkAOvKdinZzUAHAqHiOT2zmi44iLjADAeoAFB0mmAFNzRp4SUD2kAGTegAmOTpTcUADqnUurddgFJGVhA5OwI6twLq0a5hwAWUsoARAc0AGbagBZJUAPdeIhsQ1tmDC5YIh01LCzaW11i1NiZpLc6gdNwkk5jzAWDKlsTp9tHbmjQ2F63NriD24d2ax3YCxMIedObFqDPjjOsAM0N39tzVIbCHajgrEUAwf667FWqpGTMTtsRAT+BXU21Ep7FUAHkuD50mIHPUZA2GgAYKAJ9fBkojkALIJgAw5SfSgQAOvJhgBWccegAoOUAPX0tJADHcoAQA9ACS3jiwA0HJ4blNsX99zegAaA8+bYMEX1vv8MleyYBmNfrYyjDjhTtgAGlQDFs3aATl7s5rMgE4qdpbikWNkANJyBJthzTIAJvgLimmKjOFwvSjA8B6t4LsuarAhMif7WJk5DdUn5BSJk1g6rSACeyWpgQIG8mhxSGQdV8hEj6M6LRpV3yT7-sA8BlsIhr3jJEKQDQUgACc0F9S1sbS22LCWLL6dwIZrRFx8hwmZZS7AoQovLBAVlnLlx8uBcK0KUIxFUutzJIYbYDBeS8HXQAMVzJMPO6UoOBfoyOVcIbpXUQXIANz1AAoctRRpKAXGMsPI0xl66ABKId6CLvzZMItI6y19a2hB+g7WJiMurWdp02B1ZddzEO9bHctvdZSGla1gA87UABhGgBhv0AAZyKoCBXERNFaSXEFG8hZR4fw-JgcpAoHEXTo4sHYCoPkbomB3ksFACkQDR16AXADh5vSUOQdZAB8j1HrAsf51Sokb6JNQCEKuLQXJiRniI+R-4YAcJgBcHYBcSIfgzaxYSNUVnix2ec8CxLggf9+cQfbLF1gRAKAUH5Pp98II3iAGh3OI8QRfYDZ--CX8Kpcy9YAL+X5hhfHFXErlX+mWmeNAIAOANAAScigQAC8aACTEwAXP6AEQdJ2ZxRdI8N1zmQKgZCy8F5b3XxwxTEUABragAKdUaMgQAAOmAEDI8ktB-uA4ktD0H4OAhE5h6iWnEMGdM-cxzrnPO+ekHN7B8xLZq+S9SNLt+PGG9UyUMr1XJ8daFMSPDoPVAUnCb2wo8T9PGdpNR-ZzH2Pp+0DIHNPgQj275PzyTmH6dycL6p5eUAQA)

## （一）[基本变量的类型限制](https://www.tslang.cn/docs/handbook/basic-types.html)

### 0. 基本类型

- TypeScript 最基本的数据类型包括：**布尔、数字、字符串、null、undefined**

### 1. `any`：任意类型

当不确定某个变量是什么类型时，可以使⽤ any 作为这个变量的类型

### 2. `enum`：枚举类型

- 可以把类型限制在指定的场景之内
- 默认情况下，从 0 开始为元素编号。
- 也可以手动的指定成员的数值
- 当某一项不是数值类型时，该项后面的枚举都需要初始化
  ::: example
  blogs/framework/typeScript/baseEnum
  :::

```ts
enum Color {
  Red,
  Green,
  Blue
}
let c: Color = Color.Green
```

### 3. [never：任何类型的子类型](https://www.cnblogs.com/zhangguicheng/p/15733416.html)

任何类型的子类型，也就是说  `never`  可以赋值给任何类型。

```ts
const a: number = '' as never
const b: object = '' as never
```

### 4. `void`：没有任何类型

- `void`类型像是与`any`类型相反，它表示**没有任何类型**，
- 当一个函数没有返回值时，你通常会见到其返回值类型是  `void`

```ts{1}
function warnUser(): void {
  console.log('This is my warning message')
}
```

### 5. `&`：交集提取出两个类型都拥有的类型

### 6. `|`：类型联合

定义枚举类型，这样可以把类型限制在指定的场景之内

```ts{2,7}
// 定义course1变量的类型为字符串或者数字，赋值为这两个类型都不会报错
let course1: string | number = '玩转vue 3'
course1 = 1
// course1 = true // 报错

// type⽤来限制变量只能赋值为⼏个字符串的⼀个，score的取值只能是代码中三个值之⼀。
type courseScore = '好' | '⾮常好' | '嘎嘎好'
let score1: courseScore = '好'
let score2: courseScore = '⼀般好' // 报错
```

## （二）对象的类型限制（`interface`）

通过`interface`接⼝可以定义对象的类型限制

| 标题           | 说明                                                               |
| -------------- | ------------------------------------------------------------------ |
| `某个类型+[] ` | 表示语法定义类型为某个类型组成的**数组**，等同于`Array<某个类型> ` |
| `?`            | 表示 设置 为可选属性                                               |
| `readonly`     | 表示 设置为只读属性，如果对其进⾏修改就会报错                      |

```ts{5,6}
// 通过interface接⼝可以定义对象的类型限制
interface 对象的类型限制 {
  名称: string
  幸运数字: number[] //使⽤number[] 语法定义类型为数字组成的数组
  爱好?: string | boolean // 通过 ?设置 为可选属性
  readonly 国籍: string // readonly设置为只读属性，如果对其进⾏修改就会报错。
}
let person: 对象的类型限制 = {
  名称: '哈哈',
  幸运数字: [0, 1],
  爱好: false,
  国籍: '中国'
}
// person.国籍='美国'//报错，只读不可修改
```

## （三）函数的类型限制

- 函数的定义，参数和返回值本质上也是变量的概念，都可以进⾏类型的定义
- ⼤致语法：`function 函数名(参数:参数类型):返回值类型{} `

### 1. `function`的方式定义函数

```ts{1}
function add(x: number, y: number): number {
  return x + y
}
add(1, 2)
```

### 2. 使⽤`type`关键字去定义函数的类型（推荐）

```ts{1}
type addType = (a: number, b: number) => number
let add2: addType = function (x: number, y: number): number {
  return x + y
}
```

### 3. 使⽤`interface`关键字去定义函数的类型（推荐）

```ts
interface addInterface {
  (a: number, b: number): number
}
let add3: addInterface = function (x: number, y: number): number {
  return x + y
}
```

### 4. 使用变量的方式定义函数（可读性差，不推荐）

```ts
let add1: (x: number, y: number) => number = function (x: number, y: number): number {
  return x + y
}
add1(2, 3)
```

### 5. 函数重载的方式

- 如果你的函数本来就⽀持多个类型的参数，下⾯的代码中 reverse 函数既⽀持数字也⽀持字符串。
- 我们的要求是：**如果参数是数字，返回值也要是数字；参数是字符串，返回值也只能是字符串**。  
  所以参数和返回值都⽤ number|string 就没法精确地限制这个需求。
- 我们需要使⽤函数重载的⽅式，定义多个函数的输⼊值和返回 值类型，更精确地限制函数的类型。

```ts{4}
// 函数重载
function reverse(x: number): number
function reverse(x: string): string
function reverse(x: number | string): number | string | void {
  // typeof判断参数的类型
  // 如果参数是数字，返回值也要是数字
  if (typeof x === 'number') {
    return Number(x.toString().split('').reverse().join(''))
  }
  // 参数是字符串，返回值也只能是字符串
  else if (typeof x === 'string') {
    return x.split('').reverse().join('')
  }
}
```

## （四）宿主环境⾥的类型

| 属性          | 说明                 |
| ------------- | -------------------- |
| `Window`      | window 的类型        |
| `HTMLElement` | dom 元素类型         |
| `NodeList`    | 节点列表类型         |
| `MouseEvent`  | ⿏标点击事件的类型   |
| `IArguments`  | ⿏函数默认入参的类型 |

```ts
// window的类型
let w: Window = window
// dom元素类型
let ele: HTMLElement = document.createElement('div')
// 节点列表类型
let allDiv: NodeList = document.querySelectorAll('div')
// 标点击事件的类型
ele.addEventListener(
  'click',
  function (e: MouseEvent) {
    const args: IArguments = arguments
    w.alert(1)
    console.log(args)
  },
  false
)
```

## （五）泛型

### 1. 类型变量`<T>`

- `<T>`让我们拥有了给函数的参数定义类型变量的能⼒；
- 当我们需要**返回值的类型和参数⼀致**时，可以**在函数名之后使⽤`<>`定⼀个泛型 T**；
- 你可以理解这个 T 的意思就是给函数参数定义了⼀个**类型变量**，会在后⾯使⽤；  
  相当于【type T = arg 的类 t 型】，返回值使⽤ T 这个类型就完成了这个需求

```ts{2,6,8}
// 类型变量的参数是T，通过传入不同的参数，控制不同的类型变化
function identity<T>(arg: T): T {
  return arg
}
// 这个T就是string，所以返回值必须得是string
identity<string>('玩转vue 3全家桶')
// 这个T就是number，所以返回值必须得是number
identity<number>(1)
```

### 2. 类型推断关键字：`keyof`

keyof 语法可以获得**已知类型的属性（key）列表**，可以理解成获取对象的所有 key 值

```ts{6,7}
interface VueCourse5 {
  name: string
  price: number
}
// 使⽤keyof语法获得已知类型VueCourse5的属性列表，相当于 ‘name’|‘price’：
type CourseProps = keyof VueCourse5 // 等效于 "name" | "price"
let k: CourseProps = 'name' // k 只能是name和price选⼀个
// let k1: CourseProps = 'p' // 报错，改成price就是对的
```

### 3. 类型推断关键字： `in` 关键字：遍历

- in 关键字可以理解为 TypeScript 世界中的**遍历**
- 可以⽤于检查对象是否具有特定属性

```ts
type Courses = '玩转Vue 3' | '重学前端'
type CourseObj = {
  [k in Courses]: number // 遍历Courses类型作为key
}
// 上⾯的代码等于下⾯的定义
// type CourseObj = {
//     '玩转Vue 3': number;
//     '重学前端': number;
// }
```

### 4. `extends`：类型系统中的条件判断

- 用法：类型三元表达式`(T extends U) ? X : Y `
- 使⽤ extends 来实现类型系统中的条件判断，extends 相当于 TypeScript 世界中的**条件语句**

```ts
// 定义类型函数ExtendsType，接受泛型参数T后，
// 通过判断T是不是布尔值来返回不同的类型字符串
type ExtendsType<T> = (T extends boolean) ? "重学前端" : "玩转Vue 3"
type ExtendsType1 = ExtendsType<boolean> // type ExtendsType1='重学前端'
type ExtendsType2 = ExtendsType<string>  // type ExtendsType2='玩转Vue 3'
```

### 5. [`infer` ：给 extends 之后的变量设置类型变量](https://www.jianshu.com/p/707a304d7752)

- 用法：`type InferArray<T> = T extends (infer U)[] ? U : never;`
- infer 可以在 extends 之后的变量设置类型变量，更加细致地控制类型。
- infer 语法的限制如下：
  - infer 只能在条件类型的 extends **子句**中使用
  - infer 得到的类型**只能在`true`语句中使用**, 即`X`中使用

```ts
type InferPromise<T> = T extends Promise<infer U> ? U : never

type I7 = InferPromise<Promise<string>> // string
```

### 6. 泛型的综合运用

```js
// K extends keyof T：限制K的类型必须是T的属性之⼀
// T[K]是值的类型
function getProperty<T, K extends keyof T>(obj: T, name: K): T[K] {
    return obj[name]
}
const coursePrice: CourseObj = {
    "玩转Vue 3": 129,
    "重学前端": 129
}
getProperty(coursePrice, '玩转Vue 3')
getProperty(coursePrice, '不学前端') // 报错
```

## （六）Utility Types（⼯具类型）

### 1. [Pick](https://blog.csdn.net/weixin_44051815/article/details/123858655)

- 从类型 T 中选择指定属性 K，返回一个新的类型定义。
- 使用

```js
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};
```

- 示例：

```js{8}
interface Person {
  name: string;
  age: number;
  id: number;
  sex: 0 | 1;
}

type Woman = Pick<Person, 'name' | 'id'>// 从类型Person中只选取name和id

// 此时 Woman 等效于 Female
interface Female {
  name: string;
  id: number;
}
```

### 2. Omit

- `Omit`  与  `Pick`  作用相似，只不过  `Omit`  是：从类型 T 中排除指定属性 K ，然后返回一个新类型。
- 使用

```js
type Omit<T, K extends string | number | symbol> = {
  [P in Exclude<keyof T, K>]: T[P];
};

```

- 示例

```js{9}
interface User {
  id: number;
  name: string;
  age: number;
  sex: 0 | 1;
  tel: number;
}

type EditUser = Omit<User, 'id'> // 就是在 User 的基础上，去掉 id 属性
```

## （七）实战 & 练习

### 1. [TypeScript 在 Vuex4 中使用 TS 实战分享](https://www.yht7.com/news/195491)

### 2. 例题

需求：我们该如何定义 Interface API，使其能够限制：

- request 只能有 buy 和 comment 两个请求地址，
- 并且 comment 请求的参数中 message 是必传项

```js
// 实战练习
import axios from 'axios' function request(url: string, obj: any) { return axios.post(url, obj) }
interface Api { }
request('/course/buy', { id: 1 })
request('/course/comment', { id: 1, message: '嘎嘎好看' })
request('/course/comment', { id: 1 }) //如果message必传 怎么类型提醒缺少参数
request('/course/404', { id: 1 }) //接⼝不存在 类型需要报错
```

实现

```js{6}
import axios from 'axios'
interface Api {
    '/course/buy': { id: number },
    '/course/comment': { id: number, message: string }
}
function request<T extends keyof Api>(url: T, obj: Api[T]) {
    return axios.post(url, obj)
}
```

## （八）知识回顾

- 讲一下 泛型、 infer 关键字、`void`  和  `never`  区别。

## 【TypeScript 的优点/项目使用 TS 的好处 ❗】

| 优点                   | 描述                                                                                                       |
| ---------------------- | ---------------------------------------------------------------------------------------------------------- |
| **静态类型检查**       | 通过静态类型检查，可以在**编码阶段**就发现和修复错误，**提高代码的质量**。                                 |
| **提高项目的可维护性** | 通过类型注解和接口，其他开发者可以更容易理解和使用你的代码，可以提高代码的可读性和可维护性。               |
| **降低团队协作成本**   | 在团队开发中，TypeScript 的类型系统可以帮助所有人都对代码有相同的理解，降低沟通成本                        |
| **更好的兼容性**       | TypeScript 支持最新的 ECMAScript 特性，并可以将它们编译到旧版本的 JavaScript，以便在老版本的浏览器中运行。 |

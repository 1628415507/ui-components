## 【V8 ⾥⾯的 JIT 是什么？】

在计算机科学中，JIT 是“`Just-In-Time`”（即时编译）的缩写，它是⼀种提⾼代码执⾏性能的技术。
具体来说，在 V8 引擎（Google Chrome 浏览器和 Node.js 的 JavaScript 引擎）中，JIT 编译器在
JavaScript 代码运⾏时，将其编译成**机器语⾔**，以提⾼执⾏速度。

- 这⾥简要解释下 JIT 编译器的⼯作原理：
  1. 解释执⾏：V8 ⾸先通过⼀个解释器（如 Ignition）来执⾏ JavaScript 代码。这个过程中，代码不
     会编译成机器语⾔，⽽是**逐⾏解释执⾏**。这样做的优点是启动快，但执⾏速度较慢。
  2. 即时编译：当代码被 **多次执⾏** 时，V8 会认为这部分代码是“热点代码”（`Hot Spot`），此时 JIT 编
     译器（如 TurboFan）会介⼊，**将这部分热点代码编译成机器语⾔**。机器语⾔运⾏在 CPU 上⽐解释
     执⾏要快得多。
  3. 优化与去优化：JIT 编译器会**对热点代码进⾏优化**，但有时候它会基于错误的假设做出优化（例如
     认为某个变量总是某种类型）。如果后来的执⾏发现这些假设不成⽴，编译器需要去掉优化（Deoptimize），重新编译。
- JIT 编译器的⼀个关键优点是它能够在不牺牲启动速度的情况下，提供接近于或同等于编译语⾔的运⾏
  速度。这使得像 JavaScript 这样原本被认为执⾏效率较低的语⾔能够⽤于复杂的计算任务和⾼性能的
  应⽤场景。
- 随着 V8 和其他现代 JavaScript 引擎的不断进步，JIT 编译技术也在持续优化，以提供更快的执⾏速度
  和更⾼的性能。

## 【如何减少 JS 加载对浏览器渲染过程的阻塞】

### JS 的加载会阻塞浏览器渲染吗？

- JavaScript 的加载、解析和执⾏默认情况下**会阻塞**浏览器的渲染过程。
- 这是因为浏览器渲染引擎和 JavaScript 引擎是**单线程**的，并且 **⼆者共享同⼀个线程**。**JavaScript 在执⾏时会阻⽌ DOM 构建**，因为 JavaScript 可能会修改 DOM 结构（例如添加、修改或删除节点）。出于这个原因，**浏览器必须暂停 DOM 的解析和渲染，直到 JavaScript 执⾏完成**。
- 默认情况下，当浏览器遇到⼀个 `<script`> 标签时，会⽴即停⽌解析 HTML，转⽽下载和执⾏脚本，然后再继续 HTML 的解析和渲染。这意味着在 HTML ⽂档中的 JavaScript 脚本的下载和执⾏过程中，⻚⾯的渲染是被阻塞的。

### 如何减少 JS 加载对浏览器渲染过程的阻塞：

- 异步脚本（`async`）
- 延迟脚本（`defer`）
- 移动脚本位置  
   将脚本放在 HTML 的底部，**即`<body>` 标签的尾部**，⽽不是放在 `<head>` 中，可以让⻚⾯内容先加载显⽰，从⽽减少⽤⼾对加载过程的可感知时间。
- 动态脚本加载  
  可以使⽤ JavaScript 动态创建 `<script>` 元素并添加到 DOM 中，从而控制脚本的加载和
  执⾏时机。

```js
const script = document.createElement('script')
script.src = 'script.js'
document.body.appendChild(script)
```

现代 Web 开发中通常推荐使⽤ `async` 或 `defer` 属性，提⾼⻚⾯加载性能，尤其是对于那些需要从外部服务器加载的⼤型 JavaScript 库来说尤为关键。

## [【客户端渲染与服务器渲染】](https://cloud.tencent.com/developer/article/2487075)

### 客户端渲染(CSR)

#### CSR 原理

CSR 的核心在于前端框架在浏览器端执行，把后端返回的原始数据（通常是 JSON）与模板代码在浏览器完成拼接，生成并更新 DOM。

#### CSR 优点

- 更强的前端交互与动态性
- 前后端分离
- 减轻服务器端负载
  > 服务器主要负责返回静态资源和数据，页面拼装工作转移到浏览器端，服务器的渲染压力减少。

#### CSR 缺点

- 首屏渲染速度慢
  > 用户需要先加载所有的 JS 代码和执行脚本，然后等待数据请求完成，才会看到完整的页面。网络较差时体验不佳。
- SEO 不友好
  > 依赖 JavaScript 渲染的页面对搜索引擎爬虫来说可能是“空白页”， 除非采用预渲染或 SSR 混合等手段。
- 复杂的前端工程化
  > CSR 项目往往要考虑打包、路由、状态管理、数据处理等工程问题，团队需要具备更全面的前端技能。

### 服务器渲染(SSR)

#### SSR 原理

服务端渲染（Server Side Rendering, SSR）是指在浏览器请求页面 URL 时，**服务器将需要的 HTML 文本组装好并返回给浏览器**。浏览器解析这些 HTML 文本后，直接构建 DOM 树并展示到页面中，无需执行 JavaScript 脚本。这种方式可以显著减少首屏加载时间，提升用户体验。

#### SSR 优点：

1. **提升首屏加载速度**‌：由于 HTML 直接由服务器生成，浏览器无需等待
   > JavaScript 执行即可显示内容。而客户端渲染，需要先得到一个空的 HTML 页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 JavaScript、请求后端服务器获取数据、JavaScript 渲染页面几个过程才可以看到最后的页面，会致应用的首屏加载时间变长。
1. **‌ 更好的 SEO‌**
   > 有利于 SEO，其实就是有利于爬虫来爬你的页面，搜索引擎可以直接抓取服务器渲染的页面内容， 当别人使用搜索引擎搜索相关的内容时，你的网页排行能靠得更前，流量也就越高，有利于提高网站排名。
1. **减少客户端计算负担** ‌：服务器处理渲染任务，减轻了客户端的负担

#### 为什么服务端渲染更利于爬虫爬你的页面

- 爬虫也分低级爬虫和高级爬虫。
  - 低级爬虫：只请求 URL，URL 返回的 HTML 是什么内容就爬什么内容。
  - 高级爬虫：请求 URL，加载并执行 JavaScript 脚本渲染页面，爬 JavaScript 渲染后的内容。
- 也就是说，低级爬虫对客户端渲染的页面来说，简直无能为力，因为返回的 HTML 是一个空壳，它需要执行 JavaScript 脚本之后才会渲染真正的页面。使用服务端渲染，对这些低级爬虫更加友好一些。

#### SSR 缺点

- 服务器压力较大
  > 每次请求都要在服务器上进行页面拼装，如果遇到高并发场景，服务器负载可能会显著提高。
- 开发部署复杂
  > SSR 通常需要前后端协同开发，或者使用如 Next.js、Nuxt.js 这类兼具前后端逻辑的框架，构建流程、部署模式均比纯前端复杂。
- 交互性相对有限
  > SSR 返回静态 HTML 后，后续页面的动态交互需要在客户端使用 JavaScript“接管”，这通常称为 Hydration（注水），并非 SSR 自带的功能，但在现代框架中普遍存在。

---
highlight: a11y-dark
theme: juejin
---

## （一）ES6 新增了哪些数据类型，说一下用法。

- Symbol
  - Symbol 是一种唯一且不可变的数据类型，用于创建**独一无二的标识符**。可以使用全局 Symbol 注册表或调用`Symbol()`函数来创建 Symbol 值。
- Map、Set
  - Map 是一种键值对的**有序列表**，其中键和值可以是任意类型，并且**保持插入顺序**。
  - Set 是一种存储唯一值的集合，其中值可以是任何类型，并且不会重复。**重复的值不会被添加**
- WeakMap 和 WeakSet
  - WeakMap 和 WeakSet 类似于 Map 和 Set，但其中的键只能是对象，并且不会阻止垃圾回收。

## （一）块作用域构造 Let and Const 变量提升

### 1. 声明函数作用提升?声明变量和声明函数的提升有什么区别?

- 变量声明提升：变量申明在**进入执行上下文**就完成了。
  - 只要变量在代码中进行了声明，无论它在哪个位置上进行声明， **js 引擎都会将它的声明放在范围作用域的顶部**；
  - 对变量进行提升，只声明，不赋值，值为`undefined`
- 函数声明提升：
  - 执行代码之前会先读取函数声明，意味着可以把函数申明放在**调用它的语句后面**。
  - 只要函数在代码中进行了声明，无论它在哪个位置上进行声明， **js 引擎都会将它的声明放在范围作用域的顶部**；
- **函数>变量声明**：函数声明会覆盖变量声明，**但不会覆盖变量赋值**

  > 同一个名称标识 a，即有变量声明`var a`，又有函数声明`function a() {}`，  
  > **不管二者声明的顺序，函数声明会覆盖变量声明**，也就是说，此时 a 的值是声明的函数`function a(){}`  
  > 注意：如果在变量声明的**同时初始化 a**，或是之后对 a 进行赋值，**则会覆盖函数声明**，此时 a 的值为变量的值。

  ```js{1,3}
  var a // 变量申明没赋值,会被函数申明覆盖
  // a = 1 // 赋值则不会被覆盖
  function a() {// 变量申明函数申明
    return true
  }
  console.log('【 a 】-31',a,)//a为函数

  ```

### 2. var、let、const 的区别 ⭐⭐⭐⭐⭐

| 区别           | var                                      | let                                              | const                                                                                                                                           |
| -------------- | ---------------------------------------- | ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 是否会变量提升 | 是                                       | 必须先声明后使用                                 | 同 let                                                                                                                                          |
| 是否能重复声明 | 是                                       | 与前面的 let，var，conset 声明的变量**不能重名** | 同 let                                                                                                                                          |
| 作用域         | 在非函数作用域中定义是挂在到 window 上的 | 声明的变量只在局部起作用                         | 同 let                                                                                                                                          |
| 是否必须初始化 | 否                                       | 否                                               | ① const 声明变量的**同时必须赋值进行初始化**，一旦初始化完毕就**不允许修改**，<br>② const 定义的对象\数组中的属性值可以修改，基础数据类型不可以 |

### [ 延伸问题 ]

### （1）如何使 const 声明的对象内属性不可变，只可读？

- 如果 const 声明了一个对象，对象里面的属性是可以改变的。
- 使用`Object.freeze(obj)`冻结 obj，就能使其内部的属性不可变，但有局限，就是 obj 对象中要是有属性是对象，该对象内属性还能改变，要全不可变的话，就需要使用递归等方式一层一层全部冻结。

```js
const obj = { name: 'laona' }
obj.name = 'lili'
console.log(obj.name) //lili
//因为const声明的obj，只是保存其对象的引用地址，只要地址不变，就不会出错。
```

### （2）变量和函数怎么进行提升的？优先级是怎么样的？⭐⭐⭐

- 只要变量和函数在代码中进行了声明，无论它在哪个位置上进行声明， js 引擎都会将它的声明放在范围作用域的顶部；
- 函数>变量声明：函数声明会覆盖变量声明，但不会覆盖变量赋值

## （二）默认参数

在 ES6，我们可以直接把默认值放在函数申明里：

```js
var link = function(height = 50,  url = 'http://azat.co') {  
    ...
}
```

## （三）模板文本

```js
;`模板文本`
```

## （四）多行字符串

## （五）解构赋值

- https://blog.csdn.net/weixin_44486539/article/details/96279709

## （六）增强的对象字面量

允许在大括号里面，直接写入变量和函数，作为对象的属性和方法 \
 如：在 ES6 的对象文本中，既可以直接分配 getAccounts: getAccounts, 也可以只需用一个 getAccounts

## （七）箭头函数（三没有、三不能）

### 1. 箭头函数的特点

- **没有 arguments 实参集合**，取而代之**用...剩余运算符解决** ;
- **没有自己的 this**。他的 this 是继承当前**上下文中的 this** ;
- **没有函数原型 prototype**
- **不能作为构造函数 new**， 因为箭头函数相当于**匿名函数**，不能被 new 箭头函数;
- **不能使用 call、apply、bind 改变箭头函数中 this 指向** ;
- 不能当做 Generator 函数，不能使用 yield 关键字;

### [ 延伸问题 ]

### （1）[箭头函数和普通函数的区别？箭头函数可以当做构造函数 new 吗？](https://segmentfault.com/a/1190000021380336)

箭头函数是普通函数的简写，但是它不具备很多普通函数的特性
|区别|箭头函数|普通函数|
|-----|-----|-----|
|this 指向问题| 指向它定义时所在的对象|指向调用它的对象|
|函数提升|不会|会|
|arguments 对象|没有，如果要获取参数的话可以使用 **rest 运算符**|有 arguments|
|yield 属性|没有 yield 属性，不能作为生成器 Generator 使用|有 |

- 不能 new，原因:
  - 没有自己的 this，不能调用 call 和 apply
  - 没有 prototype，new 关键字内部需要把新对象的*proto*指向函数的 prototype

## （八）[Promises](https://juejin.cn/post/7106031956122402824/)

## （九）Classes（类）

## （十）Modules（模块）
